from __future__ import annotations

import sys
import tempfile
import textwrap
from os import PathLike
from pathlib import Path
from typing import Any

from hatchling.builders.hooks.plugin.interface import BuildHookInterface
from hatchling.plugin import hookimpl

if sys.version_info < (3, 11):
    import tomli as tomllib
else:
    import tomllib


def load_toml(file: str | PathLike) -> dict[str, Any]:
    with open(file, "rb") as f:
        return tomllib.load(f)


class VersioneerBuildHook(BuildHookInterface):
    PLUGIN_NAME = "versioneer"

    def initialize(self, version: str, build_data: dict[str, Any]) -> None:
        if version == "editable":
            return

        pyproject_toml = load_toml(Path(self.root) / "pyproject.toml")

        # evaluate the original versionscript.py file to get the computed versionfile
        versionscript = Path(pyproject_toml["tool"]["versioneer"]["versionfile_source"])
        version_py = versionscript.read_text()
        module_globals = {}
        exec(version_py, module_globals)
        version_dict = module_globals["get_versions"]()

        # replace the file with the constant version
        self.temp_version_file = tempfile.NamedTemporaryFile(mode="w", delete=True)  # noqa: SIM115
        self.temp_version_file.write(
            textwrap.dedent(f"""
                # THIS "versionfile" IS GENERATED BY versioneer
                # by evaluating the original versionscript and storing the computed versions as a constant.

                def get_versions():
                    return {version_dict}
            """).strip()
        )
        self.temp_version_file.flush()

        build_data["force_include"][self.temp_version_file.name] = Path(
            pyproject_toml["tool"]["versioneer"]["versionfile_sdist"]
        )


@hookimpl
def hatch_register_build_hook() -> type[BuildHookInterface]:
    return VersioneerBuildHook
